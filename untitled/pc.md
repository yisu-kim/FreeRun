# 무선조종차와 PC간 통신구현

{% hint style="info" %}
각 디바이스의 IP를 알고 사용자가 정한 PORT 번호가 client와 server가 같으면 **같은 와이파이 범위 내에서** 통신할 수 있습니다. 라즈베리 파이 Ubuntu MATE를 설치할 때 와이파이 설정을 해주었다면 별도의 설정 없이 바로 와이파이를 사용할 수 있습니다. PC는 iptime n100mini dongle을 사용하여 와이파이에 접속해주세요.
{% endhint %}

![](../.gitbook/assets/image%20%289%29.png)

자신의 컴퓨터 와이파이 IP 검색하기

{% tabs %}
{% tab title="Window" %}
윈도우키 + R을 눌러 실행 탭에 cmd 입력

| `ipconfig` |
| --- |
{% endtab %}

{% tab title="Ubuntu" %}
터미널 창을 실행

| `hostname -I` |
| --- |
{% endtab %}
{% endtabs %}

socket통신에 대해 알아보고, 직접 통신할 수 있는 코드를 짜보도록 합시다.

{% tabs %}
{% tab title="basic" %}
* [ ] 소켓 생성하기

```text
socket.socket() 함수를 이용해서 소켓 객체를 생성할 수 있습니다. 
서버든 클라이언트든 소켓을 이용한 네트워킹을 하기 위해서는 먼저 소켓을 생성해야합니다.
이 함수는 두 가지 인자를 받는데, 하나는 패밀리이고 다른 하나는 타입입니다.

패밀리: socket.socket()의 첫 번째 인자.
      “택배 상자에 쓰는 주소 체계가 어떻게 되어 있느냐”에 관한 것 입니다.
      흔히 .AF_INET와 .AF_INET6를 많이 씁니다. 전자는 IP4v에 후자는 IP6v에 사용됩니다.

타입: socket.socket()의 두 번째 인자.
      raw 소켓, 스트림 소켓, 데이터그램 소켓등이 있는데, 
      보통 많이 쓰는 것은 socket.SOCK_STREAM 혹은 socket.SOCK_DGRAM입니다. 
      
가장 흔히 쓰이는 socket.AF_INET, socket.SOCK_STREAM 조합은 기본 인자값 입니다. 
따라서 이 타입의 소켓을 생성하고자 한다면, 인자 없이 socket.socket()만 써도 무방합니다.
```



* [ ] 정보 주고받기

```text
소켓으로부터 데이터를 읽을 때는 sock.recv()를,
정보를 보낼 때는 sock.sendall()을 사용합니다. 

sock.recv(bufsize)는 읽어들일 데이터의 크기를 정해서 그만큼을 읽어옵니다. 
단 파일을 읽을 때처럼 반복해서 읽을 수는 없습니다. 
소켓은 한 번은 읽고 한 번은 보내는 ‘턴 바이 턴’식으로 통신하기 때문입니다.  

sock.sendall(data)은 주어진 데이터를 전송합니다.
```



* [ ] 닫기

```text
소켓 역시 외부 리소스를 열어서 사용하는 것이므로 닫는 것이 매우 중요합니다. 

연결을 종료할 때에는 서버와 클라이언트 소켓 모두를 닫아야 하며, 
이미 닫혀있는 소켓에서 데이터를 받으려 하거나 데이터를 보내려하면 오류가 발생합니다. 
소켓을 닫을 때에는 sock.close()를 사용한다.

단, 소켓 객체는 컨텍스트매니저 프로토콜을 지원하므로, 
with 문으로 사용하면 명시적으로 닫을 필요가 없습니다.
```
{% endtab %}

{% tab title="server" %}
* [ ] 바인드 \(bind\): 서버 쪽의 맵핑 방식

```text
서버가 특정 포트를 열고 입력을 기다리기 위해서, 소켓을 포트에 바인드하는 과정이 선행되어야 합니다. 
서버 쪽에서만 필요한 과정으로,
생성된 소켓 객체에 대해 sock.bind() 메소드를 사용해 실행할 수 있습니다.

바인드란 프로그램 인터페이스인 소켓과 네트워크 시스템이 자원을 구분하는 IP와 포트 번호를 연결하는 과정입니다.
프로그램/프로그래머는 자신이 사용하는 포트가 명시적으로 몇 번인지, 자신의 IP가 무엇인지 알고 있어야 합니다. 
그래야 이를 교신상대인 클라이언트에게 알려 클라이언트가 접속하도록 할 수 있습니다.
```

* [ ] 포트 듣기\(Listen\)와 열기

```text
바인드가 완료되면,
sock.listen() 메소드를 사용합니다.
이 메소드는 호출되면, 서버는 클라이언트가 해당 포트에 접속하는 것을 기다리고,
접속이 들어오면 (그것이 원하는 클라이언트인지, 임의의 접속 요청인지는 알 수 없음) 리턴됩니다.
이는 ‘듣기’만 하는 것이고, 실제로 접속을 수락하는 것은 다음 차례입니다.

listen()으로 접속 시도를 알아챘다면,
sock.accept()을 사용해 접속을 개시합니다.
이 메소드는 (소켓, 주소정보)로 구성되는 튜플을 리턴합니다. 
여기서 소켓은 실제 클라이언트와 접속이 이루어져 교신 가능한 소켓입니다. 
서버는 최초 생성되어 listen한 소켓이 아닌 accept()의 반환으로 제공된 소켓을 사용해서 클라이언트와 정보를 주고받을 수 있습니다.
왜냐하면, 소켓이라는 모델 자체가 1:N 통신을 상정하고 있기 때문입니다.
```
{% endtab %}

{% tab title="client" %}
* [ ] 연결하기 – connect

```text
클라이언트가 소켓을 생성하는 방법은 서버 측과 같습니다.
서버는 (생성->바인드->듣기->수락->읽기->쓰기->닫기)의 사이클대로 동작한다면,
클라이언트는 조금 더 단순합니다.

바인드 과정이 없으며 접속을 능동적으로 수행하기 때문에,
(생성->연결->쓰기->읽기)의 사이클이 적용됩니다.
연결은 sock.connect()를 사용하며, 사용되는 인자는 bind()와 같습니다.
```
{% endtab %}
{% endtabs %}

